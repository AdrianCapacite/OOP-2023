package ie.tudublin;

import java.util.ArrayList;
import java.util.Vector;

import processing.core.PApplet;
import processing.core.PVector;

/**
 * FlowLines
 * Flow lines is a grid of vectors which direct the flow of lines.
 *  - The vectors are generated by a Perlin noise function.
 *  - The lines are generated by a random walk.
 *  - The lines are drawn with a random colour.
 *
 */
public class FlowLines extends PApplet{
    PVector[][] vectors;

    int vecWidth;
    int vecHeight;
    int vecSize; // size of each vector
    public void settings(){
        fullScreen(P3D);
    }

    public void setup(){
        colorMode(HSB);
        background(0);
        vecSize = 20; // 20 pixels for each vector
        vecWidth = width / vecSize;
        vecHeight = height / vecSize;
        vectors = new PVector[vecWidth][vecHeight];

    }

    public void draw(){
        background(0);

        // Generate a grid of vectors
        generateVectors(0.1f, millis() * 0.0001f);
        System.out.println(millis() * 0.0001f);

        // Draw the vectors
        stroke(255);
        renderVectors();
    }

    /**
     * Generates a grid of vectors using Perlin noise.
     * @param t
     */
    void generateVectors(float scale, float t) {
        for (int i = 0; i < vecHeight; i++) {
            for (int ii = 0; ii < vecWidth; ii++) {
                noiseDetail(2, 0.5f);
                float a = map(noise(i * scale, ii * scale, t), 0, 1, 0, TWO_PI);
                vectors[ii][i] = new PVector(cos(a), sin(a)).normalize();
            }
        }
    }

    void renderVectors() {
        for (int i = 0; i < vecHeight; i++) {
            for (int ii = 0; ii < vecWidth; ii++) {
                PVector v = vectors[ii][i];
                // Draw a line from the center of the vector to the edge
                float x1 = ii * vecSize + vecSize / 2;
                float y1 = i * vecSize + vecSize / 2;
                float x2 = x1 + v.x * vecSize / 2;
                float y2 = y1 + v.y * vecSize / 2;
                line(x1,y1, x2, y2);

            }
        }
    }

    /**
     * Class represents a line in the flow field.
     * Rendering a line takes a snapshot of the flow field at the time of creation.
     * The line then follows the flow field until it reaches the edge of the screen.
     */
    class Line {
        PVector start;
        PVector velocity;
        ArrayList<PVector> points;

        Line(int x, int y) {
            start = new PVector(x, y);
            points = new ArrayList<PVector>();
            points.add(start);
        }

        public void render() {
            // Draw line
            stroke(0, 255, 255);

            // Draw points
            beginShape();
            for (PVector p : points) {
                vertex(p.x, p.y);
            }
            endShape();

        }

        public void update(PVector[][] flowField) {
            // Get vector closest to current position
            {
                PVector closestVec = flowField[0][0];
                for (int i = 0; i < flowField.length; i++) {
                    for (int ii = 0; ii < flowField[i].length; ii++) {
                        PVector v = flowField[i][ii];
                        if (v.dist(start) < closestVec.dist(start)) {
                            closestVec = v;
                        }
                    }
                }
            }
            // Apply vector to velocity
            // Add velocity to current pos to get next
            // Add next to points
        }
    }
}
